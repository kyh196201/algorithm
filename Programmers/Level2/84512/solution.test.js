// 단어의 순서 = 단어 이전에 있는 모든 단어의 개수 + 1 (자기 자신)
// ex: 단어가 EIOUU일 경우
// 1. 첫 번째 글자 : E 앞선 모음의 개수 * 781(첫 글자가 고정되었을 때 만들 수 있는 모든 단어의 개수) + 1
// 2. 두 번째 글자까지 : (E보다 뒤에 있고, EI보다 앞선 단어의 경우의 수는 EA로 시작하는 모든 단어, EE로 시작하는 모든 단어의 개수) + 1
// 3. 세 번째 글자까지 : (EI ~ EIO 사이에 있는 단어들은 EIA, EIE, EII로 시작하는 모든 단어의 개수) + 1
// 3. 네 번째 글자까지 : (EIO ~ EIOU 사이에 있는 단어의 개수) + 1
// 3. 다섯 번째 글자까지 : (EIOU ~ EIOUU 사이에 있는 단어의 개수) + 1

// word의 각 모음을 순회하면서 계산한 값을 합산
// 첫 번째 글자 : (5^0 + 5^1 + 5^2 + 5^3 + 5^4 = 781 = 등비수열의합(5)) * 모음의 인덱스 + 1
// 두 번째 글자 : (5^0 + 5^1 + 5^2 + 5^3) * 모음의 인덱스 + 1
// 세 번째 글자 : (5^0 + 5^1 + 5^2) * 모음의 인덱스 + 1
// 네 번째 글자 : (5^0 + 5^1) * 모음의 인덱스 + 1
// 다섯 번째 글자 : (5^0) * 모음의 인덱스 + 1
function solution(word) {
  let answer = 0;
  const vowels = ['A', 'E', 'I', 'O', 'U'];

  // n은 더하는 항의 개수
  const 등비수열의합 = (n = 1) => (5 ** n - 1) / (5 - 1);

  word.split('').forEach((w, index) => {
    answer += 등비수열의합(5 - index) * vowels.indexOf(w) + 1;
  });

  return answer;
}

describe('모음사전', () => {
  it('test', () => {
    expect(solution('EIO')).toBe(1189);
    expect(solution('UUUUU')).toBe(781 * 5);
  });
});
