### 문제

```
[가사 검색](https://programmers.co.kr/learn/courses/30/lessons/60060?language=javascript)
```

---

### 풀이

- Node, Trie 클래스 구조

```markdown
1. 노드를 가지고 있는 Trie(트라이) 클래스를 생성한다.

2. Trie는 최초 root 노드를 가지고 있어야하고, Trie 인스턴스 생성과 동시에 root 노드를 생성한다.

3. 각 노드는 Node 클래스를 구현해서 구성한다.

4. Node 클래스는 다음과 같이 구성된다.
{
	character: '',
	count: '',
	childs: {},
	isEnd: false,
}

5. character는 현재 노드의 문자 값을 가지고 있고, count는 방문한 횟수, childs는 자식 노드를 참조하는 객체이다. 그리고 isEnd는 마지막 노드인지 체크한다.

6. Trie에는 insert와 search 두가지 메소드가 존재한다.

7. insert는 문자열을 입력하면 문자열의 각 글자 하나씩을 순환하면서 노드를 생성한다.

8. search는 입력된 문자열을 한 글자씩 순환하면서 노드를 탐색하고, 마지막에 찾은 노드의 count를 반환한다.
```

- insert 메소드

```markdown
1. root 노드의 count를 1 증가한다.

2. root 노드의 childs 객체에서 현재 글자에 해당하는 child 노드가 있는지 체크한다.

3. 있으면 해당 노드로 이동한다. ( currentNode -> root.childs[char] )
	3.1 count를 1 증가한다.

4. 없으면 해당 노드를 생성하고 해당 노드로 이동한다. ( count를 1로 초기화한다. )

5. 계속 반복해서 마지막 글자일 경우 isEnd를 true로 설정한다.

```

- search 메소드

```markdown
0. search전에 입력된 쿼리의 ?를 모두 빈 문자열('')로 치환한다.

1. 입력된 쿼리의 길이가 없으면('??? 인 case'), root노드의 count를 리턴한다.

2. 길이가 있으면 한 글자씩 순회한다.

3. 현재 노드를 root 노드로 설정하고, 현재 노드에서 글자에 해당하는 자식 노드가 있는지 찾는다.

4. 자식 노드가 있을 경우 현재 노드를 해당 자식 노드로 변경하고, 다시 탐색을 시작한다.

5. 자식 노드가 없을 경우 0을 리턴한다.

```

- 문제 풀이

```markdown
1. words에 들어가는 단어의 길이가 1 ~ 10000자라고 했으니 10001(0 ~ 10000)의 길이를 가지는 배열을 생성하고, 초기화한다.

2. words를 순회하면서 word의 길이를 체크하고, 해당 길이와 일치하는 배열의 인덱스에 Trie 인스턴스를 2개 생성한다.

3. 2개를 생성하는 이유는, 'Toa??', '??ast' 정방향/역방향 마다 각각 하나씩 Tire 인스턴스를 만들기 위해서이다.

4. words를 순회하면서 word의 길이를 체크, 배열의 인덱스에 해당되는 위치가 비어있으면 [PreTrie, PostTrie]를 각각 생성하고, 하나의 word에 대해서 정방향/역방향 하나씩  정방향은 
각 Trie에 insert 메소드를 이용해서 문자를 집어넣는다.

5. Trie 배열 초기화가 완료되었으면, queries 배열을 순회한다.

6. queries의 각 아이템을 query라는 변수로 받고, '?'의 위치에 따라서 정방향으로 체크할건지 역방향으로 체크할 것인지 설정한다.

7. '?'의 위치가 0번 인덱스이면 (무조건 한 개 이상 있음) 역방향 트라이에, 아니면 정방향 트라이에서 탐색을 시작한다.

8. 결정한 Trie의 search 메소드를 이용해서 count값을 받고, answers에 push한다.
```
